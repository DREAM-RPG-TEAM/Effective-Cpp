# Round02

# C++를 언어들의 연합체로 바라보는 안목은 필수

---

다중 패러다임 프로그래밍 언어

: 절차적 프로그래밍을 기본으로 객체 지향, 함수형, 일반화 프로그래밍을 포함하며 메타 프로그래밍 개념까지 지원한다.

C++은 다음과 같은 하위 언어를 제공한다.

- C: 블록, 문장, 선행 처리기, 기본 제공 데이터 타입, 배열, 포인터
- 객체 지향 C++: 클래스, 캡슐화, 상속, 다형성, 가상 함수
- 템플릿 C++: 템플릿 프로그래밍, 템플릿 메타 프로그래밍(Template Metaprogramming: TMP)
- STL: 템플릿 라이브러리 - 컨테이너, 알고리즘, 함수 객체 등

C 스타일만 사용한다면 값 전달이 참조 전달보다 효율적이다. 하지만 객체 지향 C++을 사용하면 사용자 정의 생성자/소멸자 개념이 도입되면서, 상수 객체 참조자에 의한 전달 방식이 더 효율적이다. 이는 템플릿 C++에서 더욱 두드러진다.

그러나 STL을 학습하면 반복자와 함수 객체가 C의 포인터를 모델로 만들어졌다는 점을 알게 된다. 따라서 STL의 반복자 및 함수 객체에 대해서는 값 전달의 규칙이 다시 중요해진다. (매개변수 전달 방법 선택에 대한 자세한 내용은 항목 20 참조)

<aside>
💡

**기억하기**

C++을 사용한 효과적인 프로그래밍 규칙은 상황에 따라 달라집니다. 이는 C++의 어느 부분을 사용하느냐에 따라 결정됩니다.

</aside>

# #define을 쓰려거든 const, enum, inline을 떠올리자

---

가급적 선행처리자보다 컴파일러를 더 가까이 하는 것이 좋다.

```cpp
#define ASPECT_RATIO 1.653
```

ASPECT_RATIO는 컴파일러에게 보이지 않는 기호식 이름이다. 전처리기가 컴파일러에 소스 코드를 전달하기 전에 이를 숫자 상수로 대체하기 때문이다. 따라서 ASPECT_RATIO라는 이름은 컴파일러의 기호 테이블에 포함되지 않는다. 이로 인해 컴파일러 에러가 발생하면 혼란을 겪을 수 있다. 소스 코드에는 ASPECT_RATIO가 있었는데 에러 메시지에는 1.653이 나타나기 때문이다.

만약 ASPECT_RATIO가 정의된 파일이 코드 작성자의 것이 아니라면 문제는 더 복잡해진다. 1.653의 출처를 찾는 데 시간을 낭비할 수 있다. 이 문제는 기호식 디버거에서도 발생한다. 기호 테이블에 이름이 들어가지 않기 때문이다.

이러한 문제의 해결책은 매크로 대신 상수를 사용하는 것이다.

<aside>
💡

**매크로의 문제점 요약**

---

- #define으로 정의된 매크로는 컴파일 전 전처리 단계에서 숫자 상수로 대체된다. 예를 들어, `#define ASPECT_RATIO 1.653`이 있다면 전처리기가 모든 `ASPECT_RATIO`를 `1.653`으로 바꾼 후 컴파일러에 전달한다. 결과적으로 컴파일러는 `ASPECT_RATIO`라는 이름을 전혀 보지 못한다.
- `ASPECT_RATIO`와 관련된 오류가 발생하면 컴파일러는 `1.653`에 대한 오류 메시지를 출력한다. 하지만 개발자는 코드에 `ASPECT_RATIO`를 썼기 때문에 `1.653`의 출처를 파악하기 어려울 수 있다.
- 매크로로 정의된 값은 컴파일러의 기호 테이블(symbol table)에 포함되지 않는다. 따라서 디버깅 시 매크로 이름인 `ASPECT_RATIO` 대신 대체된 숫자 값만 보이게 된다. 이는 디버깅을 복잡하게 만들고 시간을 더 소요하게 할 수 있다.

⇒ #define대신 const상수를 사용하는 것이 좋다. 상수를 사용하면 컴파일러가 그 이름을 인식하고 에러 메시지나 디버깅할 때도 그 이름을 볼 수 있어 문제해결이 쉬워진다.

</aside>

## 매크로 대신 상수 사용하기

---

```cpp
const double AspectRatio = 1.654;
```

AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 컴파일러가 인식하며 기호 테이블에도 포함된다.

또한, 상수가 부동소수점 실수 타입일 경우 컴파일된 최종 코드의 크기가 #define보다 작을 수 있다. 이는 매크로를 사용하면 ASPECT_RATIO가 코드에 등장할 때마다 선행처리기에 의해 1.653으로 대체되어 목적 코드에 여러 개의 사본이 생기지만, 상수 타입의 AspectRatio는 여러 번 사용되어도 단 하나의 사본만 생성되기 때문이다.

## const상수를 사용할 때 주의할 점

---

1. 상수 포인터를 정의할 때는 주의가 필요하다. 상수 정의는 주로 헤더 파일에 포함되므로, 포인터 자체를 const로 선언해야 하며, 포인터가 가리키는 대상도 const로 선언하는 것이 일반적이다.
예를 들어, 헤더 파일에 char* 기반 문자열 상수를 정의할 때는 다음과 같이 const를 두 번 사용해야 한다.
    
    ```cpp
    const char* const authorName = "Scott Meyers";
    ```
    
    문자열 상수를 사용할 시 char*보다 string 객체가 대체적으로 사용하기 좋다.
    
    ```cpp
    const std::string authorName("Scott Meyers");
    ```
    
    <aside>
    💡
    
    const char* test = “abcd” // Error X
    
    char * test1 = “ancd” // Error
    
    ⇒> 이유는?
    
    char greeting[] = “hello”;
    
    char* const test2 = greeting;
    
    </aside>
    
    <aside>
    💡
    
    **문자열 상수를 사용할 때 char*보다 std::string 객체가 더 좋은 이유**
    
    ---
    
    char*는 문자열 저장 시 메모리를 직접 관리해야 하지만, std::string은 C++ 표준 라이브러리에서 제공하는 문자열 클래스로 메모리 관리가 자동으로 이루어진다. 이는 문자열 길이 변경, 새로운 문자열 할당, 길이 계산 등의 작업에서 특히 유용하다.
    
    - char*로 문자열을 다루는 경우, 문자열의 길이를 계산할 때마다 strlen()과 같은 함수를 호출한다. 이 함수는 매번 문자열을 순회하면서 글자의 길이를 계산하기 때문에 시간이 소요된다. 반면 std::string은 내부적으로 문자열의 길이를 미리 저장하고 있기 때문에 length()나 size()를 호출 시 바로 값을 반환할 수 있다. 즉 이미 저장된 값을 바로 반환하기 때문에 성능 면에서도 효율적이다.
    - char* 문자열은 개발자가 메모리를 직접 할당하고 해제해야 하며, 문자열 크기 변경 시 수동으로 메모리를 관리해야 한다. 이러한 관리를 잘못하면 심각한 문제가 발생할 수 있다:
        - 할당된 크기를 초과하는 문자열 복사 → 버퍼 오버플로우 발생
        - 할당된 메모리를 해제하지 않음 → 메모리 누수 발생
    </aside>
    
2. 클래스 멤버로 상수를 정의하는 경우, 즉 상수의 유효 범위를 클래스로 한정하고자 할 때는 그 상수를 클래스의 멤버로 만들어야 한다. 또한, 그 상수의 사본 개수를 한 개로 제한하고 싶다면 정적 멤버로 선언해야 한다.
    
    ```cpp
    class GamePlayer{
    	private:
    		static const int NumTurns = 5; // 선언만 한 것 초기값이 선언시점에 주어짐
    		int scores[NumTurns];
    		
    };
    ```
    
    위 코드의 NumTurns는 정의가 아니라 선언이다. C++은 보통 정의가 마련되어 있어야 하지만, 정**적 멤버로 만들어지는 정수류 타입의 클래스 내부 상수는 예외이다. 이들은 주소를 취하지 않는 한 정의 없이 선언만 해도 아무 문제가 없다.** 단, 클래스 상수의 주소를 구하거나, 주소를 구하지 않는데도 컴파일러가 잘못 만들어져 정의를 요구하는 경우에는 별도의 정의를 제공해야 한다. 아래가 그 예다.
    
    ⇒ 이 말을 잘 모르겠음
    
    ```cpp
    const int Gameplayer::NumTurns; // 정의를 한 것
    ```
    
    클래스의 상수 정의는 구현 파일에 둔다. 헤더 파일에는 두지 않는다. 정의에는 상수의 초기값을 포함하지 않는데, 이는 클래스 상수의 초기값이 선언 시점에 이미 주어지기 때문이다.
    
    클래스 상수는 #define으로 정의할 수 없다. #define은 유효 범위 개념이 없으며, 매크로는 정의 후 컴파일이 끝날 때까지 유효하다. 즉, #define은 클래스 상수를 정의하는 데 사용할 수 없으며, private 같은 어떤 형태의 캡슐화 혜택도 받을 수 없다.
    
    반면, 상수 데이터 멤버는 캡슐화가 가능하다.
    
    오래된 컴파일러는 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것을 허용하지 않는 경우가 있다. 또한, 클래스 내부 초기화를 허용하는 경우에도 정수 타입의 상수에 대해서만 국한되어 있다. 이처럼 문법이 적용되지 않는 컴파일러를 사용할 때는 초기값을 상수 '정의' 시점에 두는 것이 좋다.
    
    ```cpp
    class ConstEstimate{
    	private:
    		static const double FudgeFactor;// 정수 클래스 상수의 선언 헤더파일에 둔다.
    };
    const double
    	ConstEstimate::FudgeFactor = 1.35; // 정적클래스 상수의 정의 구현파일에 둔다.
    ```
    
    다만 해당 클래스를 컴파일하는 도중에 **클래스 상수의 값이** 필요할 때 예외가 발생할 수 있다. ⇒  컴파일 하는 도중 초깃값이 필요한데 없을 경우 예외가 발생할 수 있다는 말
    
    GamePlayer::scores등의 배열 멤버를 선언할 때가 대표적인 예이다. 따라서 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기화를 금지하는 구식 컴파일러에 대해 나열자 둔갑술(enum hack)라는 통칭으로 알려진 기법을 생각할 수 있다. 이 기법의 원리는 나열자(enumerator)타입의 값은 int가 놓일 곳에도 쓸 수 있다는 것이다. 따라서 GamePlayer는 다음과 같이 정의할 수 있다.
    
    ```cpp
    class GamePlayer{
    	private:
    		enum{ NumTurs = 5 };
    		int scores[NumTurns];
    ```
    
    이 나열자 둔갑술이 클래스 멤버 변수로서 const static을 대신하는 기능이잖아?
    const static은 주소를 
    
    이 "나열자 둔갑술"은 여러 가지 이유로 알아두면 유용하다.
    
    첫째, 나열자 둔갑술은 동작 방식이 const보다는 #define에 더 가깝다. 예를 들어, const의 주소를 얻는 것은 가능하지만, enum의 주소를 취하는 것은 불법이며 #define의 주소를 얻는 것도 불가능하다. 만약 여러분이 선언한 정수 상수의 주소를 다른 사람이 얻거나 참조자로 사용하는 것을 원치 않는다면, enum은 좋은 방어책이 될 수 있다. (코딩 방식으로 설계상의 제약을 강화하는 이런 방법은 항목 18에서 다루었으니 참고하라.)
    
    또한, 잘 만들어진 컴파일러는 정수 타입의 const 객체에 대해 저장 공간을 할당하지 않지만(그 객체에 대한 포인터나 참조자를 만들지 않는 한), 일부 컴파일러는 그렇지 않을 수 있다. 신중한 프로그래머라면 const 객체에 대한 메모리를 할당하지 않는 방법을 선호할 것이다. enum은 #define처럼 불필요한 메모리 할당을 전혀 하지 않는다.
    
    나열자 둔갑술을 알아야 하는 두 번째 이유는 실용적이다. 많은 코드에서 이 기법이 사용되고 있으므로, 이를 쉽게 알아볼 수 있도록 눈을 훈련시켜 두는 것이 좋다. 실제로, 이 나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이기도 하다(항목 48 참조).
    
    다시 선행 처리자로 돌아가보자. #define 지시자의 또 다른 흔한 오용 사례는 매크로 함수이다. 이는 함수처럼 보이지만 함수 호출 오버헤드를 발생시키지 않는 매크로를 구현하는 것이다. 다음 예를 보자. 매크로 인자들 중 큰 것을 사용해 어떤 함수 f를 호출하는 매크로이다.
    
    ```cpp
    // a와 b 중에 큰 것을 f에 넘겨 호출한다.
    #define CALL_WITH_MAX(a,b_ f((a) > (b) ? (a) : (b))
    ```
    
    이런 식의 매크로는 단점이 많다. 이런 매크로를 작성시 매크로 본문에 들어있는 인자마다 반드시 괄호를 씌워주는 것이 좋다. 그러나 이를 제대로 처리한다고 해서 끝난 것이아니다.
    
    ```cpp
    int a  = 5, b = 0;
    CALL_WITH_MAX(++a, b); // a가 두 번 증가한다.
    CALL_WITH_MAX(++a, b+10); // a가 한 번 증가한다.
    ```
    
    f가 호출되기 전에 a가 증가하는 횟수가 달라진다. 
    
    기존 매크로의 효율을 그대로 유지함은 물론 정규 함수의 모든 동작 방식 및 타입 안전성까지 완벽히 취할 수 있는 방법은 인라인 함수에 대한 템플릿을 준비하는 것이다.
    
    ```cpp
    template<typename T>
    inline void callWithMax(const T& a, const T&b){
    	f(a > b ? a : b);
    }
    ```
    
    이 함수는 템플릿이기 때문에 동일 계열 함수군을 만들어낸다. 같은 타입의 객체 두 개를 인자로 받아 둘 중 큰 것을 f에 넘겨 호출하는 구조다. 함수 본문에 괄호를 덧칠할 필요가 없고, 인자를 여러 번 평가할 우려도 없다. 게다가 callWithMax는 실제 함수이므로 유효 범위와 접근 규칙을 그대로 따른다. 따라서 클래스 내부에서만 사용 가능한 인라인 함수로도 구현할 수 있다. 반면 매크로는 이런 개념 자체를 적용할 수 없다.
    
    const, enum, inline을 염두에 두면 선행처리자를 사용해야 하는 경우가 크게 줄어든다. 그러나 완전히 사용을 피하기는 어렵다. 예를 들어, #include는 여전히 필수적이며, #ifdef/#ifndef도 컴파일 조정 기능으로 실무에서 자주 사용된다. 
    
    <aside>
    💡
    
    **암기 포인트 !**
    
    ---
    
    - 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자
    - 함수처럼 쓰이는 매크로를 만들려면 #define 매크로보다 인라인 함수를 우선 생각한다.
    </aside>