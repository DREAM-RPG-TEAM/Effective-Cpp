# 항목 1 : C++를 언어들의 연합체로 바라보는 안목은 필수

---

## 1.

- 초기 C++은 C언어에 객체지향이 결합된 형태였음 (C with Classes)

## 2.

- 꾸준한 성장으로 변화됨:
• 예외 - 함수 구성 방식의 헤게모니
• 템플릿 - 프로그램 설계에 대한 사고방식
• STL - 확장성

## 3.

오늘날의 C++은 다중패러다임 프로그래밍 언어로 불림:

- 절차적 프로그래밍 (기본)
- 객체지향 프로그래밍
- 함수식 프로그래밍
- 일반화 프로그래밍
- 메타 프로그래밍

⇒ 각 지원하는 프로그래밍 마다 적절한 사용 규칙이 있다해도 각 프로그래밍에는 다 예외가 있다. 이런 C++을 어떻게 공부하는 것이 효율 적일까?

## 4.

C++을 단일 언어로 바라보는 눈을 넓혀 상관관계가 있는 여러 언어들의 연합체로 보자!
각 언어에 대한 규칙을 각개격파하라! C++은 여러개의 하위 언어를 제공하고 있다.

C++은 4가지 하위 언어로 구성됨 :  C, 객체지향 개념의 C++, 템플릿 C++ , STL

- C
    - C++은 여전히 C를 기본으로 함
    - C의 기본적인 기능: 블록, 문장, 선행처리자, 기본 제공 데이터 타입, 배열, 포인터
    - C만 사용해도 되나 그러면 C++의 좋은 기능은 사용하지 못한다.
- 객체지향 개념의 C++
    - 클래스를 쓰는 C에 관한 모든 것
    - 클래스(생성자와 소멸자), 캡슐화, 상속, 다형성, 가상함수(동적바인딩) 등
- 템플릿 C++
    - C++의 일반화 프로그래밍의 특징
    - C++의 강력한 기능
- STL
    - 템플릿 라이브러리로 컨테이너, 반복자, 알고리즘, 함수객체가 있음
    - 특수한 사용규약 존재

## 5.

C++은 4가지 하위언어로 이루고 있고 효과적인 프로그램 개발을 위해 한 하위언어에서 다른 하위언어로 옮겨가면서대응전략을 바꾸는 상황이 오더라도 당황하지 말아야함을 명심하자

- 예시
    - C++의 C부분 : **값 전달이 참조전달보다 효율적**
    - C++의 객체지향 C++과 템플릿  C++ : **상수객체 참조자에 의한 전달이 효율적**
        - 객체지향 C++ : 사용자 정의 생성자/ 소멸자 개념 등
        - 템플릿 C++ : 사용하는 객체의 타입을 알 수 없음
    - C++의 STL : 반복자와 함수 객체가 C의 포인터를 본떠 만듦, 반복자 및 함수 객체에 대해 **값 전달에 대한 규칙이 더 효율적**

## 6.

C++은 한 가지 규칙 아래 뭉친 통합 언어가 아니라 네 가지 하위 언어들의 연합체이다.각각의 하위 언어가 자신만의 규칙을 가지고 있다. 

<aside>
💡

**기억하기**

C++을 사용한 효과적인 프로그래밍 규칙은 상황에 따라 달라집니다. 이는 C++의 어느 부분을 사용하느냐에 따라 결정됩니다.

</aside>

# 항목 2 : #define을 쓰려거든 const, enum, inline을 떠올리자

---

## 1.

> 가급적 선행 처리자 보다 컴파일러를 더 가까이 하자
> 

#define은 C++언어 자체의 일부가 아닌 것으로 취급될 수 있는데 이 점은 문제가 될 수 있다. 예를들어 다음과 같은 코드가 있을 때

```cpp
#define ASPECT_RATIO 1.653
```

소스코드가 컴파일러에게 넘어가기 전에 성행차리자가 ASPECT_RATIO를 밀어버리고 숫자 상수로 바꾸어 버리기 때문에 우리에겐 ASPECT_RATIO가 기호식 이름(Symbolic name)으로 보이지만 는 컴파일러에게 보이지 않는다. 

그 결과, ASPECT_RATIO라는 이름은 컴파일러가 쓰는 기호 테이블에 들어가지 않는다. 따라서 숫자 상수로 대체된 코드에서 컴파일 에러가 발생하면 헷갈릴 수 있다.

소스 코드에선 분명히 ASPECT_RATIO 가 있었는데 에러 메시지엔 1.653이 있다. 만약SPECT_RATIO 가 정의된 파일이 직접 작성한 코드가 아니라면 1.653이 어디에서 왔는지 모를 수 있고 이것을 찾느라 곤란해질 수 있다. 이 문제는 이 기호테이블에 이름이 들어가지 않기 때문에 기호식 디버거(symbolic debugger)에서도 나타날 소지가 있다. 

## 2.

해당 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.

```cpp
const double AspectRatio = 1.654; // 대문자로만 표기하는 이름은 대개 매크로에 쓰는 것이어서, 이름 표기도 바꾼다.
```

AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 컴파일러의 눈에도 보이며 기호 테이블에도 들어간다. 

게다가 상수가 **부동소수점 실수 타입**일 경우에는 컴파일을 거친 최종 코드의 크기가 #define을 썼을 때보다 작게 나올 수 있다. 
 그 이유는, 매크로를 쓰면 코드엔 ASPECT_RATIO 가 등장하기만 하면 성행처리자에 의해 1.653으로 모두 바뀌면서 결국 목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만 상수 타입의 AspectRatio 는 아무리 여러 번 쓰이더라도 사본은 딱 하나만 생기기 때문이다.

### reference )

---

https://steemit.com/kr/@modolee/floating-point

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/fa406e72-08e9-4b6d-92fd-20b01ca2dbaf/image.png)

## 3.

**#define 을 상수로 교체**하려는 분께는 **딱 두 가지 경우**를 조심해야 한다.

- 첫 번째 ) 상수 포인터를 정의하는 경우이다.
    - 상수 정의는 대게 헤더파일에 넣는 것이 상례이므로(다른 소스 파일이 이것을 include해서 쓰게 됨) 포인터는 꼭 const로 선언해 주어야 하고 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다. 이를테면 어떤 헤더 파일안에 char*기반의 문자열 상수를 정의한다면 다음과 같이 const를 두번 써야 한다는 말이다. *const 의미와 사용법에 대한 자세한 사항(항목3)참고*
        
        ```cpp
        const char* const authorName = "Scott Meyers";
        ```
        
        문자열 상수를 사용할 때 위와 같이 char*기반의 구닥다리 문자열보다 string객체가 대체적으로 사용하기 괜찮다. 따라서 cuthorName은 다음과 같이 정의하는 것이 좋다.
        
        ```cpp
        const std::string authorName("Scott Meyers");
        ```
        
- 두 번째 ) 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우이다.
    - **어떤 상수의 유효범위를 클래스로 한정하고자 할때는** 그 상수를 멤버로 만들어야 하는데, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static)멤버로 만들어야 한다.
        
        ```cpp
        class GamePlayer{
        	private:
        		static const int NumTurns = 5; // 선언만 한 것 초기값이 선언시점에 주어짐
        		int scores[NumTurns];
        		
        };
        ```
        
        위에서 본 NumTurns는 **정의가 아닌 선언(declaration)**된 것이다.
         C++에서는 사용하고자 하는 것에 대해 **정의**가 마련되어 있어야 하는 게 보통이지만, 정적 멤버로 만들어지는 **정수류(각 정수 타입, char, bool 등) 타입**의 클래스 내부 상수는 예외이다.  
        이들에 대해 주소를 취하지 않는 한 , 정의 없이 선언만 해도 아무 문제가 없게 되어 있다. 
        
        선언만 하면 문제가 있어 정의를 해야 하는 경우 :
        
        - 클래스의 상수 주소를 구한다던지,
        - 주소를 구하지 않는 데도 직접 쓰는 컴파일러가 잘못 만들어진 관계로 정의를 요구하는 경우 별도의 정의를 제공해야 한다.
    - 아래는 그 예이다.
        
        ```cpp
        const int Gameplayer::NumTurns; // 정의값이 주어지지 않는 이유는 아래에
        ```
        
        이때 클래스 상수의 정의는 헤더파일에는 두지 않고 구현 파일에 둔다.
        **클래스 상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 때문에**(즉, NumTurns는 선언될 당시에 바로 초기화된다는 것이다) **정의에는 상수의 초기값이 있으면  안된다.**
        

## 4.

주의할 것이 하나 있다. #define은 유효범위가 뭔지도 모르기 때문에 클래스 상수를 #definde으로 만드는 것은 방법 자체가 말이 안 된다. 
매크로는 일단 정의되면 컴파일이 끝날 때까지(중간에 #undef되지만 않으면) 유효한다는 점을 기억해 두자! 
정리하자면, #define은 클래스 상수를 정의하는 데 쓸 수도 없을 뿐 아니라 어떤 형태의 캡슐화 혜택도 받을 수 없다. 말하자면 private 성격의 #define같은 것은 없다. 
그러나 상수 데이터 멤버는 캡슐화가 된다. NumTurns가 그런것이다.

## 5.

```cpp
class GamePlayer{
	private:
		static const int NumTurns = 5; // 선언만 한 것 초기값이 선언시점에 주어짐
		int scores[NumTurns];
		
};
```

조금 오래된 컴파일러는 **위의 문법**을 받아들이지 않는 경우가 종종 있다. 이유는 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 대개 맞지 않다고 판단하기 때문이다. 
게다가 클래스 내부 초기화를 허용하는 경우가 **정수 타입의** 상수에 대해서만 국한되어 있다. 따라서 **위의 문법이 먹히지 않는 컴파일러를 쓸 때는** 초기값을 **상수 ‘정의’시점에** 주도록한다.

```cpp
class ConstEstimate{
	private:
		static const double FudgeFactor;// 정수 클래스 상수의 선언 헤더파일에 둔다.
};
const double
	ConstEstimate::FudgeFactor = 1.35; // 정적클래스 상수의 정의 구현파일에 둔다.
```

웬만한 경우라면 이것으로 충분하지만 딱 한 가지 예외가 있다면 해당 클래스를 컴파일하는 도중에 클래스 상수의 값이 필요할 때이다. 이를테면 GamePlayer::scores 등의 배열 멤버를 선언할 때가 대표적인 예이다(컴파일러는 컴파일 과정에서 이 배열의 크기를 알아야 한다면 버틸 것이다). 그렇기 때문에 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기화를 금지하는(다시 말하지만 이것은 표준에 어긋난 구식이다) 구식 컴파일러에 대한 배려로서 괜찮은 방법을 추천한다면 ‘나열자 둔갑술(enum hack)이라는 통칭으로 멋스럽게 알려진 기법을 생각할 수 있다. 이 기법의 원리는 나열자 타입의 값은 int가 놓일 곳에도 쓸 수 있다는 c++ 의 진실을 적극 활용하는 것이다. 따라서 GamePlayer는 다음과 같이 정의할 수 있다.

```cpp
class GamePlayer{
	private:
		enum{ NumTurs = 5 };
		int scores[NumTurns];
		....
};
```

## 6.

이  나열자 둔갑술은 알아 두면 도움이 된다.

- 첫째) 나열자 둔갑술은 동작 방식이 const보다는 #define에 더 가깝다.
    - 예를들어, const의 주소를 잡아내는 것은 합당하지만, enum의 주소르르 취하는 것은 불가능하며 #define의 주소를 얻는 것은 맞지 안는다. 혹시 선언한 정수 상수를 가지고 다른 사람이 주소를 얻거나 참조자를 쓴다는 것이 싫다면 enum은 아주 좋은 자물쇠가 될 수 있다.*(코딩 방식의 결정을 통해 설계상의 제약을 강화하는 방법은 항목 18에서 참고)*
    또한 제대로 만들어진 컴파일러는 정수 타입의 const 객체에 대해 저장공간을 준비하지 않겠지만(그 객체에 대한 포인터나 참조자를 만들지 않는 한) 조금 편찮게 만들어진 컴파일러는 반대로 동작할 수 있어서 소심한 프로그래머 측면에선 양쪽 모두에 대해 안전하게 const 객체에 대해 메모리를 만들지 않는 방법을 쓰고 싶을 것이다. enum은 #define처럼 어떤 형태의 쓸데없는 메모리 할당도 절대 저지르지 않는다.

## 7.

- 두 번째) 상당히 많은 코드에서 이 기법이 쓰이고 있으므로 이것을 발견했을 때 쉽게 알아보도록 눈을 단련시키기 위함이다.
    - 나열자 둔갑술은 템플릿 메타 프로그래밍의 핵심기법이다*(항목 48 참조)*

## 8.

다시 선행처리자에 집중. 많은 경우에서 볼 수 있는 #define 지시자의 또 다른 오용 사례는 메크로 함수이다. 함수처럼 보이지만 **함수 호출 오버헤드를 일으키지 않는** 메크로를 구현하는 것이다.

아래의 예는 매크로 인자들 중 큰 것을 사용해서 어떤 함수 f를 호출하는 메크로이다.

```cpp
// a와 b 중에 큰 것을 f에 넘겨 호출한다.
#define CALL_WITH_MAX(a,b_ f((a) > (b) ? (a) : (b))
```

이런 식의 매크로는 단점이 한두 개가 아니다. 

## 9.

이런 매크로를 작성할 때는 표현식을 매크로에 넘길때마다 골치아픈 일이 발생할 수 있으므로 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워 주는 센서를 잊지 말아야 한다. 그러나 이 부분을 제대로 처리한다해서 끝난 것이 아니다.

```cpp
int a  = 5, b = 0;
CALL_WITH_MAX(++a, b); // a가 두 번 증가한다.
CALL_WITH_MAX(++a, b+10); // a가 한 번 증가한다.
```

비교를 통해 처리한 결과가 어떤 것이냐에 따라 달라져 f가 호출되기 전에 a가 증가하는 회수가 달라진다. 

## 10.

기존 매크로의 효율은 그대로 유지함은 물론 정규 함수의 모든 동작방식 및 타입 안정성까지 완벽히 취할 수 있는 방법이 있으므로 C++에서는 함수 호출을 없애 준다는 명목하에 자행되는 이런 작태를 참을 필요가 없다. 바로 인라인 함수에 대한 템플릿*(항목 30 참조)*을 준비하는 것이다.

```cpp
template<typename T>
inline void callWithMax(const T& a, const T&b){
	f(a > b ? a : b);
}
```

이 함수는 템플릿이기 때문에 동일 계열 함수군(family of function)을 만들어낸다. 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조이다. 함수 본문에 괄호로 분칠을 해 댈 필요가 없고 인자를 여러번 평가할 지도 모른다는 걱정도 없다. 뿐만 아니라 callWithMax는 진짜 함수이기 때문에 **유효 범위 및 접근 규칙**을 그대로 따라간다. 임의의 클래스 안에서만 쓸 수 있는 인라인 함수에 대한 이야기가 나오더라도 전혀 이상하지 않다. 하지만 매크로의 경우엔 이런 말이 나오는 것 자체가 의미가 없다.

## 11.

const, enum, inline을 유념해두면 선행처리자를 꼭 써야 할 일이 많이 줄어든다. 그렇다고 현실적으로 #defeine은 부동의 필수 요소로 남아 있고, #ifdef/#ifnde도 컴파일 조정 기능으로 현장에서 잘 쓰이기 때문에 완전히 사용하지 않는 것은 힘들다. 그냥 알아두자.

<aside>
💡

**암기 포인트 !**

---

- 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자
- 함수처럼 쓰이는 매크로를 만들려면 #define 매크로보다 인라인 함수를 우선 생각한다.
</aside>

# 항목 3 : 낌새만 보이면 cont를 들이대 보자

---

## 1.

const는 의미적인 제약(const키워드가 붙은 객체는 외부 변경을 불가능하게 한다)을 소스 코드 수준에서 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다. 어떤 값(객체의 내용)이 불변이어야 한다는 **제작자의 의도를 컴파일러 및 다른 프로그래머**와 나눌 수 있는 수단이다. 

*소스코드 수준 : 컴파일 단게

## 2.

const키워드는 팔방미인이다. 

- 클래스 바깥에서는 전역 혹은 네임스페이스 유효범위를 상수 선언(정의)하는데 쓸 수 있다.(항목2 참조) 그뿐 아니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다.
- 클래스 내부의 경우 정적 멤버 빛 비정적 데이터 멤버 모두 상수로 선언할 수 있다.
- 포인터의 경우 기본적으로 포인트 자체를 상수로, 혹은 포인터가 가리키는 데이터를 상수로 지정할 수 있는데 둘 다 지정할 수 도 있고 아무것도 지정하지 않을 수도 있다.
    
    ```cpp
    
    	char greeting[] = "Hello";
    	char* p = greeting;
    	const char* p = greeting; // 포인터가 가리키는 대상이 상수
    	char* const p = greeting; // 포인터 자체가 상수
    	const char* const p = greeting; // 포인터가 가리키는 대상 및 포인터가 다 상수
    ```
    
    const는 변덕스러워 보이지만 그렇지 않다. const의 키워드가 `*`표의 **왼쪽에 있으면** **포인터가 가리키는 대상**이 상수인 반면 const가 `*`표의 **오른쪽에 있는 경우 포인터 자체**가 상수이다. const가 `*`표의 **양쪽에 다 있으면 포인터가 가리키는 대상 및 포인터가 다** 상수라는 뜻이다.
    

## 3.

포인터가 가리키는 대상을 상수로 만들 때 const를 사용하는 스타일은 조금씩 다르다.

어떤 프로그래머는 타입 앞에 const를 붙이기도 한다. 그 외에는 타입의 뒤쪽이자 `*` 표의 앞에 const를 붙이는 사람들이 있다. 의미적인 차이가 없다. 즉 아래의 함수들이 받아들이는 매개변수 타입은 모두 똑같다.

```cpp
void f1(const Widget *pw);

vodi f2(Widget const *pw);
```

두 가지 형태 모두 현업에서 잘 쓰이므로 눈이 어색하지 않게 잘 익혀두자.

## 4.

STL반복자는 포인터를 본 뜬 것이기 때문에 기본적인 동작 원리 T*포인터와 진짜 흡사하다. 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉, T* const포인터)과 같다.반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만, 반복자 가리키는 대상 자체는 변경이 가능하다. 만약 변경이 불가능한 객체를 가리키는 반복자(즉, const T*포인터의 STL 대응물)가 필요하다면 const_iterator를 쓰면 된다.

```cpp
std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin(); //iter는 T* const처럼 동작
*iter = 10; //ok, iter가 가리키는 대상을 변경한다.
++iter; //에러! iter는 상수이다.

std::vector<int>::const_iterator cIter = vec.begin(); //cIter는 const T*처럼 동작
*cIter = 10; //에러! *cIter가 상수이기 때문에 안 된다.
++cIter; //이건 문제없다. cIter를 변경
```

const의 가장 강력한 용도는 함수 선언에 쓸 경우이다. 함수 선언문에 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 객체에 대해 const의 성질을 붙일 수 있다.

## 5.

함수 반환 값을 상수로 정해주면 안전성이나 효율을 포기하지 않고도 사용자측의 에러 돌발 상황을 줄이는 효과를 자주 볼 수 있다. 한 예로, 항목 24에서 살펴볼 유리수 클래스 operator*함수가 어떻게 선언되어 있는지를 보도록한다.

```cpp
class Rational{...};
const Rational operator*(const Rational& lhs, const Rational& rhs);
```

operatr*의 반환 값이 상수 객체일 이유를 어디서 찾겠냐, 그런데 상수 객체로 되어 있지 않으면 사용자 쪽에서 저지르는 아래와 같은 어처구니 없는 실수를 지켜볼 수 밖에 없게 된다.

```cpp
Rational a, b, c;
...
(a * b) = c; //상수가 아니라면 가능한 코드
```

## 6.

두 수의 곱에 대입 연산을 취하고 싶을 수도 있지만 이 경험을 해 본 프로그래머가 전자보다 훨씬 많다 .어쩌다가 키보드를 잘못 누른것이다(그리고 bool 암시적 변환이 가능한 타입도 포함된다.)

```cpp
if(a * b = c) ... // 나는 원래 a * b == c를 비교하려고 했는데...
```

위의 코드는 a및 b의 타입이 기본제공 타입이었다면 용서 없이 문법 위반에 걸리는 코드이다. 훌륭한 사용자 정의 타입들 특징 중 하나는 기본 제공 타입과의 쓸데 없는 비호환성을 피한다는 것이다.*(항목 18참조)* ㅇ위에서 본바와 같이 두 수의 곱에 대해 대입 연산이 되도록 놓아두는 것이 바로 쓸데없는 경우가 된다. operator*의 반환 값을 const로 정해 놓으면 이런 경우를 사전에 막을 수 있다. 따라서 상수 반환 값 지정이 정답이 된다.

## 7.

const 매개변수에 대해서는 특별히 새로 할 이야기가 없다. 그냥 const 타입의 지역 객체와 특성이 똑같다. 그리고 이것을 가능한 항상 사용하도록 하자. 매개변수 혹은 지역 객체를 수정할 수 없게 한느 것이 목적이라면const로 선언하는 것을 잊지 말자. 그렇다면 컴파일 에러를 실수로 쳤네 와 같은 컴파일 에러를 보게 될 일이 없다.

## 상수 멤버 함수

---

## 8.

멤버 함수에 붙는 const 키워드는 **“해당 함수가 상수 객체에 대해 호출될 함수이다”라는 사실을 알려주는 것이다.** 

**이 키워드가 중요한 이유 2 가지 :**

- 첫 번째 )  클래스의 인터페이스를 이해하기 좋게하기 위함이다.
    - 그 클래스로 만들어진 객체를 변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자 쪽에서 알고 있어야 한다는 것이다.
- 두 번째) 이 키워드를 통해 상수 객체를 사용할 수 있게 하자는 것인데, 코드의 효율을 위해 중요한 부분이다.
    - 항목20에서 이야기 하고 있듯이 C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나는 객체를 '상수 객체에 대한 참조자'로 전달하는 것이다. 이 기법이 제대로 작동하려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수, 즉 상수 멤버 함수가 준비되어 있어야 한다는 점이 핵심이다.

## 9.

 const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다. ← c++의 아주 중요한 성질이니 꼭 외워두자

문서의 한 구역을 나타내는 데 쓰려고 만든 클래스의 예시

```cpp
class TextBlock {
public:
	const char& operator[](std::size_t position) const { return text[position]; }// 상수 객체에 대한 operator[]
	char& operator[](std::size_t postion) { return text[postion]; }  // 비상수 객체에 대한 operator[]
private:
	std::string text;
};
```

위에 선언된 TextBlock의 operator[]는 다음과 같이 사용할 수 있다.

```cpp

	TextBlock tb("Hello");
	std::cout << tb[0]; // 비상수 멤버를 호출
	const TextBlock ctb("World");
	std::cout << ctb[0]; // 상수 멤버를 호출
```

## 10.

**실제 프로그램에서 상수 객체가 생성되는 주요 경우 :** 

- 첫 번째 ) 상수 객체에 대한 포인터로 전달 될때
- 두 번째 ) 함수에 상수 객체에 대한 참조자로 객체를 전달될 때

앞서 본 ctb 예제는 개념 이해를 돕기 위한 것이며**, 아래의 예제가 실제 사용 사례**에 더 가깝다:

```cpp
void print(const TextBlock & ctb) {
    std::cout << ctb[0];
}
```

operator[]를 오버로드하여 각 버전마다 반환 타입을 다르게 설정했기 때문에, TextBlock의 상수 객체와 비상수 객체의 사용 방식이 달라진다.

```cpp
std::cout << tb[0];	// 좋습니다. 비상수 버전의
							      // TextBlock 객체를 읽습니다.
	tb[0] = 'X';	// 역시 문제없죠. 비상수 버전의
					      // TextBlock 객체를 씁니다.
	std::cout << ctb[0];	// 이것도 됩니다. 상수 버전의
							          // TextBlock 객체를 읽습니다.
	ctb[0] = 'X';	// 컴파일 에러 발생! 상수 버전의
					      // TextBlock 객체에 대해 쓰기는 안 됩니다 
					      // return 타입에러
}
```

**주의할 것이 하나 있는데, 넷**째 줄에서 발생한 에러는 반환 타입 때문이다. operator[]호출이 잘못된 것은 없다.  해당 에러는 const char& 타입에 대입 연산을 시도했기 때문에 생긴 것이다.  상수 멤버로 선언된 operator[]의 반환 타입이 const char&이기 때문이다.

## 11.

하나 더 눈 여겨 볼 수 있는 것은 operator[]의 비상수 멤버가 char의 참조자를 반환한다는 것인데, char 하나만 쓰면 안 된다는 것을 꼭 주의하자. 만약 operator[]가 단순히 char을 반환하도록 구현되어 있다면, 다음과 같은 문장이 컴파일되지 않는다:

```cpp
tb[0] = 'x';
```

이 문장이 컴파일되지 않는 이유는 기본 제공 타입을 반환하는 함수의 반환 값을 수정할 수 없기 때문이다. 설령 이것이 문법적으로 허용된다 하더라도, C++에서는 '값에 의한 반환'을 수행하는 특성*(항목 20 참조)*이 있다. 즉, 수정되는 값은 tb.text[0]의 사본일 뿐, tb.text[0] 자체가 아니다. 아마 의도하고자 한 동작은 아닐 것이다.

## 12.

어떤 멤버함수가 상수멤버함수라는 것이 어떤 의미일까? 여기에는 굵직한 양대 개념이 자리잡고 있다.  하나는 비트 수준 상수성(bitwise constness, 다른말로 물리적 상수성(physical constness)이고 또 하나는 논리적 상수성이다.

## 13.

---

- 비트 수준 상수성(bitwise constness, 다른말로 물리적 상수성(physical constness)):  비트 수준 상수성은 **어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야(정적 멤버는 제외) 그 멤버함수가 const로 인정되는 개념이다.** 즉, 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다. 이 개념을 사용하면 상수성 위반을 쉽게 발견할 수 있다. 컴파일러는 데이터 멤버에 대한 대입 연산의 수행 여부만 확인하면 되기 때문이다. 실제로 C++에서 정의하는 상수성이 바로 이 비트 수준 상수성이다. 그리고 **상수 멤버 함수는 그 함수가 호출된 객체의 어떤 비정적 멤버도 수정할 수 없다.**

## 14.

그러나  **제대로 const로** 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 존재한다. 어떤 포인터가 가리키는 대상을 수정하는 멤버 함수들 중 상당수가 이에 손한다. 하지만 그 포인터가 객체의 멤버로 존재하는 한, 이 함수는 비트 수준 상수성을 갖는 것으로 간주되어 컴파일러도 문제를 제기하지 않는다. 그러나 이로 인해 예상치 못한 동작이 발생할 수 있다. 예를 들어, TextBlock과 비슷한 클래스를 하나 만들어서 갖고있는데 내부 데이터를 string이 아닌 char*로 관리한다고 가정해보자. 이는 string 객체를 사용할 수 없는 C API에도 이것을 쓸 수 있게 하기 위함이다.

```cpp
class CTextBlock {
public:
char& operator [] （std::size_t position） const // 부적절한 （그러나 비트수준
{ return pText [position] ； } // 상수성이 있어서 허용되는）
															// operator[] 의 선언
private:
char *pText;
};
```

코드에서 볼 수 있듯이, operator[] 함수가 상수 멤버 함수로 선언되어 있다. 이는 잘못된 것이다. 그럼에도 불구하고 이 함수는 해당 객체의 내부 데이터에 대한 참조자를 그대로 반환한다*(자세한 내용은 항목 28 참조)*. operator[]의 내부 코드만 살펴보면 pText를 직접 수정하지 않는다는 점은 분명하다. 따라서 컴파일러는 이 operator[]에 대한 코드를 생성할 때 문제를 제기하지 않는다. 결국 비트 수준에서 상수성을 유지하고 있고, 컴파일러는 이 정도만 확인하면 되기 때문이다.
하지만 이로 인해 어떤 문제가 발생할 수 있는지 아래에서 살펴보자.

```cpp
const CTextBlock cctb("Hello");  // 상수 객체를 선언합니다.
char *pc = &cctb[0];             // 상수 버전의 operator[]를 호출하여 cctb의
                                 // 내부 데이터에 대한 포인터를 얻습니다. 
*pc = 'J';                       // cctb는 이제 "Jello"라는 값을 갖습니다.
```

이 예제는 상수성의 문제점을 명확히 보여준다. 어떤 값으로 초기화된 상수 객체를 하나 만들어 놓고 이것에다 상수 멤버함수를 호출했더니 값이 변경되었다!

<aside>
📢

비트 수준 상수성은 상수 객체와 상수멤버를 호출해서 생성했으므로 어떠한 데이터 멤버도 수정하지 않아야 한다.  그러나 상수 객체와 상수멤버를 호출해서 코드를 짯음에도 불구하고 불구하고 객체의 값이 변경 되는것이 비트 수준 상수성의 한계이다. 
⇒ 어떻게 변경되느냐? 포인터접근을 통해 값을 변경 할 수 있음

</aside>

## 15.

논리적 상수성(logical constness)논리적 상수성은 비트 수준 상수성의 한계를 보완하기 위해 등장한 개념이다. 이 개념에 따르면, 상수 멤버함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되 그것을 사용자측에서 알아채지 못하게만 한다면 상수 멤버 자격이 있다. 

예를 들어, CTextBlock 클래스는 문장 구역의 길이를 사용자들이 요구할 때마다 이 정보를 캐시해둘 수 있다. 따라서 다음과 같은 멤버를 둘 수 있다.

```cpp
class CTextBlock {
public:
    std::size_t length() const;
private:
    char* pText;
    std::size_t textLength;    // 직전에 계산한 텍스트 길이
    bool lengthIsValid;        // 이 길이가 현재 유효한가?

std::size_t CTextBlock::length() const
{
    if (!lengthIsValid) {
        textLength = std::strlen(pText);  // 에러! 상수 멤버 함수에서
        lengthIsValid = true;             // textLength와 lengthIsValid에
    }                                     // 대입할 수 없습니다.
    return textLength;
}
};
```

이 length() 구현은 자명하게 '비트 수준 상수성'과 멀리 떨어져 있다. textLength와 lengthIsValid가 변경될 수 있기 때문이다. 그러나 CTextBlock의 상수 객체에 대해서는 논리적으로 문제가 없어 보인다. 하지만 컴파일러는 비트 수준 상수성을 검사하므로 에러를 발생시킬 것이다. 이런 상황을 어떻게 해결할 수 있을까?

## 16.

해답은 간단하다. C++의 마법 같은 키워드 mutable을 사용하면 된다. mutable은 비정적 데이터 멤버를 비트 수준 상수성의 제약에서 해방시켜주는 강력한 키워드이다.

```cpp
class CTextBlock {
public:
    std::size_t length() const;
private:
    char* pText;
    mutable std::size_t textLength;  // 이 데이터 멤버들은 언제든
    mutable bool lengthIsValid;      // 수정 가능합니다. 심지어 상수
};                                   // 멤버 함수 내에서도 가능합니다.

std::size_t CTextBlock::length() const
{
    if (!lengthIsValid) {
        textLength = std::strlen(pText);  // 이제 문제없습니다.
        lengthIsValid = true;             // 당연히 문제없죠.
    }
    return textLength;
}
```

## 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법

---

## 17.

mutable은 **‘생각지도-않던-비트-수준-상수성이-웬-말이냐’** 를 한 단어로 해결하는 훌륭한 방법이지만, const와 관련된 모든 문제를 완벽히 해결하지는 못한다.

예를 들어,  TextBlock(및 CTextBlock)의 operator[] 함수가 현재는 특정 문자의 참조자만 반환하지만, 추가 기능을 넣을 수 있다. 경계 검사, 접근 정보 로깅, 내부 자료 무결성 검증 등이 그 예이다. 이런 코드를 operator[]의 상수/비상수 버전에 모두 넣으면 *(이제 만만치 않게 길어진 '암시적' 인라인 함수를 보며 조마조마했던 마음도 일치감치 은하계 저편으로날아가고 말이죠 - 항목 30을 보세요)*, 우리 앞에 코드 중복의 괴물이 나타나게 된다.

```cpp
class TextBlock {
public:
const char& operator[](std::size_t position) const
{
    … // 경계 검사
    ... // 접근 데이터 로깅
    ... // 자료 무결성 검증
    return text[position];
}
char& operator[](std::size_t position)
{
    … // 경계 검사
    ... // 접근 데이터 로깅
    ... // 자료 무결성 검증
    return text[position];
}
private:
std::string text;
};
```

이는 심각한 코드 중복이다. 코드 중복과 함께 따라오는 문제들*—컴파일 시간 증가, 유지보수 어려움, 코드 크기 증가—*은 더 큰 골칫거리이다. 경계 검사 등의 자질구레한 코드를 별도의 멤버 함수(물론 private멤버로)로 옮겨두고 이것을 operator[]의 두 버전에서 호출하는 방법도 있지만, 여전히 중복이 존재한다. 함수 호출이 두 번씩 발생하고, return 문도 중복된다.

## 18.

operator[]의 핵심 기능을 한 번만 구현하고 이를 두 번 사용하고 싶을 것이다. 다시 말해, operator[]의 두 버전 중 하나만 제대로 만들고 다른 버전은 이것을 호출하는 식으로 구현하고 싶을 것이다. 이런 생각을 하다 보면 const 껍질을 캐스팅으로 날리면 어떨까 하는 아이디어에 도달하게 된다. 

## 19.

**기본적으로 캐스팅은 일반적으로나 통념적으로나 좋지 않은 아이디어다.** 하지만 코드 중복도 결코 좋은 아이디어는 아니다. 지금의 경우, operator[]의 상수 버전은 비상수 버전과 하는 일이 정확히 같다. 단지 다른 점이 있다면 반환 타입에 const 키워드가 붙어 있다는 것뿐이다. 따라서 여기서는 캐스팅을 써서 반환 타입으로부터 const 껍질을 벗기더라도 안전하다. 왜냐하면 비상수 operator[] 함수를 호출하는 쪽이라면 그 호출부에는 비상수 객체가 있을 것이 분명하기 때문이다. 그렇지 않다면 애초에 비상수 멤버 함수를 호출할 수 없었을 것이다. 따라서 캐스팅이 필요하긴 하지만, 안전성도 유지하면서 코드 중복을 피하는 방법은 **비상수 operator[]가 상수 버전을 호출**하도록 구현하는 것이다.

```cpp
class TextBlock {
public:
    const char& operator[](std::size_t position) const // 이전과 동일
    {
        … // 경계 검사
    ... // 접근 데이터 로깅
    ... // 자료 무결성 검증

        return text[position];
    }
    char& operator[](std::size_t position) // 상수 버전 operator[]를 호출하고 끝
    {
        return const_cast<char&>( // operator[]의 반환 타입에 캐스팅을 적용,
                                  // const를 떼어냅니다.
            static_cast<const TextBlock&>(*this)[position] // *this의 타입에 const를 붙이고
                                                           // operator[]의 상수 버전을 호출합니다.
        );
    }
};
```

보면 알겠지만 캐스팅이 두 번 사용되었다. 우리의 목표는 비상수 operator[]가 상수 버전을 호출하게 하는 것이다. 그러나 비상수 operator[] 내에서 단순히 operator[]를 호출하면 재귀적으로 자기 자신을 호출하게 된다. 이런 무한 재귀를 피하려면 "상수 operator[]를 호출하고 싶다"는 의도를 코드로 표현해야 하는데, 이를 직접적으로 할 방법이 없다. 그래서 차선책이 this의 타입을 캐스팅하는 방법이다. **원래의 타입인 TextBlock&에서 const TextBlock&으로 변환하는 것이다.**  원래의 타입이 TextBlock&에서 const TextBlock&으로 바꾸는 것이다. 즉, 캐스팅을 쓴 이유는 const가 붙어야 하기 때문이었다. 정리하자면, 두 개의 캐스팅 중 첫 번째 것은 *this에 const를 붙이는 캐스팅이고*(비상수 operator[]에서 상수버전을 호출하기 위해)* , 두 번째 것은 상수 operator[]의 반환 값에서 const를 떼어내는 캐스팅이다.

## 20.

const를 붙이는 캐스팅은 안전한 타입 변환*(비상수 객체에서 상수 객체)* 을 강제로 진행하는 것이기 때문에 static_cast만 써도 딱 맞는다. 반면, const를 제거하는 캐스팅은 const_cast밖에 없으므로 별다른 선택의 여지가 없다.(하긴 기술적으로 안 되는 건 없다. C 스타일 캐스팅을 쓰면 잘 되긴 한다. 하지만 항목27에서 볼 수 있듯이 그런 캐스팅은 잘 된 선택이라고 보기 힘들다. static_cast 혹은 const_cast 등의 키워드가 낯설다고 느껴지면 항목 27참조) 

## 21.

어찌됐든 연산자 함수 하나를 호출하는 것이 전부이다. 그래서인지 문법이 조금 이상해 보이기도 한다. 그러나  operator[]의 상수 버전을 써서 비상수 버전을 구현한 것만 가지고 코드 중복을 피하자는 의도는 충족시킬 수 있었다. 비상수 멤버함수의 구현에 상수 멤버 쌍둥이를 사용하는 기법 자체는 알아둘 가치가 있으므로 기억해두자.

## 22.

앞의 방법을 뒤집어서 하는 쪽(즉, 코드 중복 회피를 위해 상수 버전이 비상수 버전을 호출하게 만드는 것)도 생각할 수 있는데, 그것은 우리가 원하는 바는 아니다. 상수 멤버함수는 해당 객체의논리적인 상태를 바꾸지 않겠다고 컴파일러와 굳게 약속한 함수인 반면, 비상수 멤버함수는 이런 약속 같은 걸 하지 않는다. 즉, 어쩌다가 상수 멤버에서 비상수 멤버를 호출하게 되면 수정하지 않겠다고 약속한 그 개게를 배신하는 셈이 되고 그 객체는 변경될 위험에 빠질 수 있다. 따라서 상수 멤버 함수에서 비상수 멤버함수를 호출하면 틀리다는 얘기가 나온다. 실제로, 상수 멤버함수에서 비상수 멤버 함수를 호출하는 코드를 어떻게든 컴파일하면 const_cast를 적용해서 *this에 붙은 const를 떼어내야하는데, 이것이 온갖 재앙의 씨앗이다. 이것의 역순 호출은 안전성에서 문제가 없다. 비상수 멤버함수안에서는 그 객체를 바꾸든 안 바꾸든 맘대로 할 수 있기 때문에, 거기에서 상수 멤버함수를 호출한다고 해서 특별히 잘못될 리가 없다. 위의 코드에서 보았듯이 *this에 대해 staitc_cast가 제대로 작동하는 이유가 바로 이 때문이다. const에 관련된 위험이 없기 때문이다.

## 23.

const는 대단한 축복이다.

포인터나 반복자에 대해 그렇고 포인터/반복자/참조자가 가리키는 객체에 대해 그렇고 함수의 매개변수 및 반환 타입에 대해서도 마찬가지이며 지역변수는 물론이고 멤버함수에까지 const는 매우 든든한 친구이다. 할 수 있다면 남발하자 

<aside>
📢

이것만은 잊지 말자!

- const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줍니다. const
는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을
수 있으며, 멤버 함수에도 붙을 수 있습니다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 여러분은 개념적인(논리적인）상수성을 사용해서 프로그래밍해야 합니다.
- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드
중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요
</aside>

# 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

---

## 1.

C++은 객체의 값의 초기화를 보장되는 경우와 보장되지 않는 경우가 있다.

```cpp
int x ; // 어떤 상황에서는 값이 확실히 초기화(0으로)됨, 또 다른 상황에서는 보장되지 않음
```

 

```cpp
class Point{
	int x, y;
}

...

Point P; // 어떨때는 초기화가 보장되지만 어떨때는 안 됨
```

## 2.

초기화 되지 않은 값을 읽을 시 미정의 동작이 발생하여 위험성을 경고한다.

- 미초기화 객체를 읽기만 해도 프로그램이 서버리고 하지만 대부분의 경우 적당히 무작위 비트의 값을 읽고 객체의 내부가 이상한 값을 갖게 됨
⇒ 무한 디버깅으로 이

## 3.

C++은 초기화 값 보장에 대해 명확한 규칙이 있다.

- 보장이 없는 경우 : C++의 C부분만 쓰고, 초기화에 런타임 비용이 소모될 수 있는 상황
- 보장이 때때로 달라지는 경우 : C가 아닌 부분
- EX) 배열(C++의 C)의 각 원소와 달리, vector(C++의 STL)은 보장을 갖게 됨

## 4.  (기본제공타입과 비멤버객체 초기화~)

가장 좋은 방법은 모든 객체를 사용하기 전에 항상 초기화를 하는 것!!

- 기본 제공 타입과 비멤버 객체는 직접 초기화하기
    
    ```cpp
    int x = 0; // int의 직접 초기화
    const char * text = "A C-style string";// 포인터의 직접 초기화（항목 3도 참조）
    
    double d;  //입력 스트림에서 읽음으로써 
    std::cin >> d;// “초기화" 수행
    
    ```
    
- 이런 부분을 제외하고 C++의 초기화의 나머지부분은 생성자로 귀결됨
    - 생성자에서 지킬 규칙 : 생성자에서는 그 객체의 모든 것을 초기화 하자!

## 5. (생성자에서의 데이터 멤버 초기화~)

생성자에서는 **대입(assignment)**과 **초기화(initialization)**를 헷갈리지 않아야 한다.

C++의 규칙은 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 **초기화** 되어야 한다. 

주소록의 개인별 기재사항을 나타내는 클래스를 한 예를 들어보자. 이 클래스의 생성자는 다음과 같이 구현되어 있다고 가정하자!

```cpp
class PhoneNumber { . . . };

class ABEntry { // ABEntry = "Address Book Entry"
public:
	ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones);

private:
	std::string theName;
	std::string theAddress;
	std::list<PhoneNumber> thePhones; 
	int numTimesConsulted;
 };
 
 
ABEntry::ABEntry(const std::string& name, const std::string& address, 
const std::list<PhoneNumber>& phones) 
{ 
theName = name; // 지금은 모두 '대입'을 하고 있다. '초기화'가 아니다.
theAddress = address;
thePhones = phones;
numTimesConsulted = 0;
}
```

C++ 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화 되어야 한다고 명기되어 있다.  

현재의 ABEntry 생성자에서 theName, theAddress 및 thePhones는 초기화는 진작 지나갔고 여기서 초기화 되고 있는 것이아니라 어떤 값이 대입되고 있는 것이다. 정확히 말하자면 ABEntry  생성자에 진입하기도 전에 이들 **세 데이터 멤버의** **기본 생성자가 호출**되었다. 

그럼 numTimesConsulted도 초기화 되었을까? 기본 제공 타입의 데이터 멤버이기 때문에 꼭 그런것은 아니다. 기본 제공 타입의 경우에는 (생성자 안에서) 대입되기 전에 초기화되리란 보장이 없다.

## 6.

ABEntry 생성자를 좀 더 멋지게 만드는 방법은 대입문 대신 멤버 초기화 리스트를 사용하는 것이다.

```cpp
ABEntry::ABEntry(const std::string& name, const std::string& address, 
const std::list<PhoneNumber>& phones)
: theName(name), // 이제 이들은 모두 초기화가 되고 있다.
  theAddress (address),
  thePhones(phones),
  numTimesConsulted(0) 
 {}// 생성자 본문엔 이제 아무것도 들어가 있지 않는다.
```

데이터 멤버에 사용자가 원하는 값을 주고 시작한다는 점에서는 똑같지만, 초기화리스트를 사용하여 만든 생성자는 앞의 것보다 효율적일 가능성이 크다. 

대입만 사용한 버전의 경우 theName, theAddress 및 thePhones에 대해 기본 생성자를 호출해서 초기화를 미리 해 놓은 후 에 생성자에서 곧바로 새로운 값을 대입하고 있다.  따라서 먼저 호출된 기본 생성자에서 해 놓은 초기화는 아깝게도 그냥 헛짓이 되고 말았다. 

 초기화 리스트에 들어가는 인자는 바로 데이터 멤버에 대한 생성자의 인자로 쓰이기 때문에 멤버 초기화 리스트를 사용하면 이 문제를 피해 갈 수 있다.

초기화 리스트를 사용한 경우, theName은 name으로부터 복사 생성자에 의해 초기화되고, theAddress는 address로부터 역시 복사 생성자에 의해 초기화되며, thePhones도 동일한 과정을 거쳐 phones로부터 초기화된다. 

**대부분의 데이터 타입에** 대해서는, 기본 생성자 호출 후에 복사 대입 연산자를 연달아 호출하는 이전의 방법보다 **복사 생성자를 한 번 호출하는 쪽**이 더 효율적이다. 

(나만의 결론)

## 7.

앞에서 말한 **‘대부분의 타입’**에 포함되지 않는 타입이 numTimesConsulted와 같은 **기
제공 타입**이다. 기본제공 타입의 객체는 초기화와 대입에 걸리는 비용의 차이가 없지만,역시 멤버 초기화 리스트에 모두 넣어 주는 쪽이 가장 좋다.

또, 데이터 멤버를 **기본 생성자로** 초기화하고 싶을 때**도** 멤버 초기화 리스트를 사용하는 습관을 들이자. 생성자 인자로 아무것도 주지 않으면 되니까 그리 힘든 일도 아닐 것다. 예를 들어, 매개변수 없는 생성자가 ABEntry 클래스에 들어 있었다면, 아마 아래처럼 구현할 수 있을 것이다.

```cpp
ABEntry::ABEntry()
: theName(),            // theName의 기본 ctor를 호출합니다.
  theAddress(),         // theAddress에 대해서도 그렇게 하고요. 
  thePhones(),          // thePhones에 대해서도 그렇게 하'지만, 
  numTimesConsulted(0)  // numTimesConsulted는 명시적으로 
{}                      // 0으로 초기화합니다
```

어떤 데이터 멤버가 멤버 초기화 리스트에 들어가지 않았고 그 데이터 멤버의 타입이 사용자 정의 타입이면, 컴파일러가 자동으로 그들 멤버에 대해 기본 생성자를 호출하게 되어 있기 때문이란 이유로 위와 같이 하는 건 **오바가 아닌가** 생각할 수 있다.

 틀린 이야기는 아니지만 기본 생성자이든 아니든 **클래스 데이터 멤버는 모두 초기화 리스트에 항상 올려주는 센스**를 정책으로 박아 둬야만, 어쩌다가 리스트에서 어떤 멤버를 빼먹었을 때 어떤 멤버가 초기화되지 않을 수 있다는 사실을 끌고 가야 하는 부담이 없어지 게 된다. numTimesConsulted가 멤버 초기화 리스트에서 빠졌다고 생각해 보자. 멤버의 타입은 기본제공 타입이니까, 이것이 초기화될지 안 될지 장담을 못하는 것이다. 그냥 갔다가는 프로그램이 미정의 동작에 빠질 수도 있다.

## 8.

기본제공 타입의 멤버를 초기화 리스트로 넣는 일이 **선택이 아니라 의무**가 될 때도 있다. 상수와 참조자는 대입 자체가 불가능하기 때문에 **상수이거나 참조자로 되어 있는 데이터 멤버**의 경우엔 반드시 초기화되어야 합니다. (이것은 아주 중요)*(항목 5도 참조)*. 

어떤 경우는 데이터 멤버를 꼭 초기화해야 하고 또 어떤 경우는 안 해도 되는 경우를 외우면서 하루하루를 힘겹게 사느니, 멤버 초기화 리스트를 항상 사용하는 편이 더 쉬울 것이다.  필수적으로 그래야 할 때도 있는데다가, 대입보다 더 효율적일 경우가 많기도 하고….

## 9.

현장에서 쓰이는 클래스들 중 상당수가 여러 개의 생성자를 갖고 있다. 각 생성자마다. 멤버 초기화 리스트가 붙어 있는데, 만약 이런 클래스에 데이터 멤버와 기본 클래스가 적지 않게 붙어 있다면, 생성자마다 주렁주렁 매달려 있는 멤버 초기화 리스트의 모습은 그리 예쁘게 보이지 않을 것이다. 

이럴때는 대입으로도 초기화가 가능한 데이터 멤버들을 초기화 리스트에서 빼내어
별도의 함수로 옮기는 것도 나쁘지 않다. 

이들에 대한 대입 연산을 하나의(대개 private 멤버)함수에 몰아놓고, 모든 생성자에서 이 함수를 호출하게 하는 것이다.

이 방법은 데이터 멤버의 진짜 초기값을 파일에서 읽어온다든지 데이터베이스에서 찾아오는 경우에 특히 유용하게 사용할 수 있다. 하지만 일반적인 경우만 따지면 대입을 통한 가짜 초기화보다는 진짜 멤버 초기화(초기화 리스트를 통한)가 아무래도 좋다.

## 10.

C++에서의 객체 초기화는 꽤나 변덕스럽다.

꼭 알아두어야 하는 변덕스럽지 않은 부분은 바로 객체를 구성하는 데이터의 초기화 순서이다.이 순서는 어떤 컴파일러를 막론하고 항상 똑같다.

① 기본 클래스는 파생 클래스보다 먼저 초기화되고*(항목 12도 참조)* 

② 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.

 ABEntry를 예로 들면 theName이 항상 첫 번째로 초기화되고, theAddress가 두 번째, thePhones;가 세 번째, numTimesConsulted가 마지막으로 초기화된다. 선언된 순서와 같다. 어쩌다가 멤버 초기화 리스트에 이들이 넣어진순서가 다르더라도(애석하게도 이건 컴파일됩니다) 초기화 순서는 그대로이다. 여러분의 코드를 읽는 다른 사람들의 혼동도 막고 ‘무척이나’ 찾아내기 힘든 동작 버그도 피하자는 의미에서, 멤버 초기화 리스트에 넣는 멤버들의 순서도 클래스에 선언한 순서와 동일하게 맞춰 주도록 하자.

## 11. (정적객체의 초기화~)

필자의 미주알고주알 잔소리 덕택에 기본제공 타입의 비멤버 객체도 직접 초기화했고
클래스 생성자의 멤버 초기화 리스트를 써서 기본 클래스와 데이터 멤버까지 단단히 초기화했다. 이제 걱정거리가 딱 하나 - 비지역 정적 객체의 초기화 순서는 개별 [**번역 단위에서](https://www.notion.so/01-C-C-14a6bac8ff358120a1efeb1e941c25e0?pvs=21)** 정해진다는 사실이다.

## 12.

**정적 객체(static object)**는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다. 그러니까 스택 객체 및 힙 기반 객체는 애초부터 정적 객체가 될 수 없다.  정적 객체의 범주에 들어가는 것들은

① 우선 전역 객체가 있고, 

② 네임스페이스 유효범위에서 정의된 객체, 

③ 클래스 안에서 static으로 선언된 객체, 

④ 함수 안에서 static으로 선언된 객체,  - 지역 정적 객체

⑤ 그리고 파일 유효범위에서 static으로 정의된 객체, 

이렇게 다섯 종류가 된다.

이들 중 함수 안에 있는 정적 객체는 **지역 정적 객체(local static object)**라고 하고(함수에 대해서 지역성을 가지므로), 나머지는 **비지역 정적 객체(non-local staticobject)**라고 합니다. 

이 다섯 종류의 객체, 합쳐서 정적 객체는 프로그램이 끝날 때 자동으로 소멸된다. 다시 말해, main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다는 것이다.

## 13.

**번역 단위(translation unit)**는 컴파일을 통해 하나의 **목적 파일(object file)**을 만드는 바탕이 되는 소스 코드를 일컫는다. 여기서 **번역**은 소스의 언어를 기계어로 옮긴다는 의미이다. 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include하는 파일(들)까지 합쳐서 하나의 번역 단위가 된다.

### reference

---

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/81f402fd-9edf-44d3-b866-ab5cb4651fa0/image.png)

1. **번역 단위 gpt**
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/7781c67e-4b0d-45af-adde-0054dfaec1e9/image.png)
    

## 14.

자, 그러니까 작금의 문제는 이렇게 정리된다.

별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체(전역 객체, 네임스페이스에 있는 객체, 클래스 혹은 파일에 있는 정적 객체)가 한 개 이상 들어 있는 경우에 어떻게 되느냐이다.

그리고 실제적인 문제는 이것이다. 한쪽 번역 단위(소스코드)에 있는 **비정적 객체**의 초기화가 진행되면서 다른 쪽 번역 단위(소스코드)에 있는 **비지역 정적 객체**가 사용되는데, 불행히도 이 (다른 쪽 번역 단위(소스코드)에 있는) 객체가 초기화되어 있지 않을지도 모른다는 점이다.
이유는 위에서 말했듯이 별개의 번역 단위에서 정의된 **비지역 정적 객체들의 초기화 순서는 ‘정해져 있지 않다**’라는 사실 때문에 그렇다.

### reference

---

![내가 그린 그림](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/b29c0b74-ab91-4eaf-942d-e2a757b4bd21/image.png)

내가 그린 그림

## 15.

예제를 하나 살펴보자.

인터넷에 있는 파일을 마치 로컬 컴퓨터에 있는 것처럼 보이게 하는 파일 시스템을 나타내는 **Filesystem이라는 클래스**가 여러분에게 있다고 가정해보자. 

이 클래스는 주변의 모든 파일을 단일 파일 시스템처럼 보이게끔 하니까, 아마도 이런 단일 파일 시스템을 나타내는 특수한 객체가 전역 유효범위 혹은 네임스페이스 유효범위에 들어 있어야 한다.

```cpp
class FileSystem { // 여러분의 라이브러리에 포함된 클래스
public:
 std::size_t numDisks () const; // 많고 많은 멤버 함수들 중 하나
};

* extern FileSystem tfs； // 사용자가 쓰게 될 객체
                         // "tfs" = "the file system*
```

FileSystem 객체가 그리 가볍지 않다는 점은 분위기로 보아 확실하므로, 이 클래스로 만든 객체가 초기화되기(생성자가 호출되기) 전에 그 객체를 사용한다는 것은 대재앙을 일으키는 셈이다.

### reference

---

1.`static`과 `extern`의 차이

- **`extern`**: 변수나 함수가 **다른 파일에서 정의되었음을 알리는 선언**으로, 여러 파일 간 전역 객체를 공유할 때 사용한다.
- **`static`**: 변수나 함수의 **범위를 파일 내부로 제한**하여 외부에서 접근하지 못하게 한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/f2acd6d3-980c-44bc-b97e-dcb3410e798a/image.png)

## 16.

이제 이 객체의 사용자 쪽으로 초점을 돌려보자. 

파일 시스템 내의 디렉토리를 나타내는 클래스를 사용자가 만들었다고 가정했을 때 이 클래스는 tfs를 사용하는 게 자연스러울 것이다.

```cpp
class Directory {  // 라이브러리의 사용자가 만든 클래스
public:
Directory( params );
	...
 };
 
Directory::Directory( params )
{
	...
	std::size_t disks = tfs.numDisks(); // tfs 객체를 여기서 사용함
	...
}
```

어차피 가정이니, 한 발짝 더 나아가 봅시다.

이제는 이 사용자가 Directory 클래스를 사용해서 임시 파일을 담는 디렉토리 객체 하나를 생성하기로 마음먹었다.

```cpp
 Directory tempDir( params ); // 임시 파일을 담는 디렉토리
```

정적 객체의 초기화 순서 때문에 문제가 심각해질 수도 있는 상황이 드디어 눈앞에 나타났다.

tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화 되지도 않았는데 tfs를 사용하려고 할것이다. 그러나 tfs와 tempDir은 제작자도 다르고 만들어진 시기도 다른데다가 소재지(소스 파일)도 다릅니다.

다시 말해 이들은, 다른 번역단위 안에서 정의된 **비지역 정적 객체**이다.

 어쨌든 **tempDir 전에 tfs가 초기화되게 만들고 싶은데,** 이 당면 **목표를** 어떻게 달성할 수 있을까?

## 17.

단언컨대 안 된다.

서로 다른 번역 단위(소스코드)에 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않는다.

비지역 정적 객체들의 초기화에 대해 **‘적절한 순서’**를 ****결정하기란 매우매우 어렵다.

**가장 일반적인 형태** 一 *암시적 템플릿 인스턴스화로 생성된 비지역 정적 객체(그 자체도 암시적 템플릿 인스턴스화로 생겼을 수 있겠지요)가 여러 번역 단위에 들어 있는 경우* ㅡ**를** 놓고 시작해 보아도 **초기화 순서를** 어떻게 정해야 맞는지 알 수도 없을 뿐더러, 맞는 순서를 결정할 수 있는 특수한 상황을 찾는 일도 그다지 **보람이 없는 경우**가 대부분이다.

## 18.

한 가지 다행스러운 사실은 **설계에 약간의 변화만 살짝 주면** 이 문제를 사전에 봉쇄할 수 있다는 점이다. 방법도 간단한데, 비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 각 객체를 넣는 것이다. 함수 속에서도 이들은 정적 객체로 선언하고, 그 함수에서는 이들에 대한 참조자를 반환하게 만든다. 사용자 쪽에서는 비지역 정적 객체를 직접 참조하는 과거의 폐단을 버리고 이제는 함수 호출로 대신한다.

자, 정리하면 **‘비지역 정적 객체’**가 **‘지역 정적 객체’**로 바뀐 것이다**[**이쯤 되면, 디자인 패턴에 관심이 많은 분이라면 이것이 **단일체 패턴(Singleton pattern)**의 전형적인 구현양식임을 바로 알 수 있겠지요**]**

## 19.

지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다.  이것은 C++에서 보장하는 사실이며, 위의 방법은 바로 그 사실을 이용한 것 이다. 

따라서 비지역 정적 객체를 직접 접근하지 않고 지역 정적 객체에 대한 참조자를 반환하는 쪽으로 바꾸었다면, 여러분이 얻어낸 참조자는 반드시 초기화된 객체를 참조하도록 맞추어 주어야 한다. 

그리고 비지역 정적 객체 대신에 준비한 **‘지역객체 참조자 반환’** 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않게 막아야 한다. 진짜 비지역 정적 객체의 경우엔 막고 자시고 할 일도 없다.

## 20.

그리하여 tfs와 tempDir에 이 방법을 적용한 결과를 보시겠습니다.

```cpp
class FileSystem { ... }; // 이전과 다를 것 없는 클래스

FileSystem& tfs ()  // tfs 객체를 이 함수로 대신합니다. 이 함수는 클래스 안에 정적 멤버로 들어가도 됩니다.
{ 
	static FileSystem fs; //지역 정적 객체를 정의하고 초기화합니다. 
	return fs; //이 객체에 대한 참조자를 반환합니다.
}
 class Directory { ... }; // 역시 이전과 다를 것 없는 클래스
 
 Directory::Directory( params ) // 이전과 동일합니다. tfs의 참조자였던 것이 지금은 tfs() 로 바뀌었다는 것만 다릅니다.
{ 
	...
	std::size_t disks = tfs().numDisk();
	...
 }
Directory& tempDir()  // tempDir 객체를 이 함수로 대신합니다. 이 함수는 Directory 클래스의 정적 멤버로 들어가도 됩니다.
{
	static Directory td;  // 지역 정적 객체를 정의/초기화합니다.
	return td; // 이 객체에 대한 참조자를 반환합니다
}
```

tfs와 tempDir 대신에 tfs() 와 tempDir ()을 참조하는 것으로 바뀐 게 전부이므로 사용자는 원래 하던 대로 프로그램을 만들면 된다. 즉, 정적 객체 자체를 직접 사용하지 않고 그 객체에 대한 참조자를 반환하는 함수를 사용하고 있는 것이다.

### reference

---

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a637ac8a-c1bd-4bee-96db-a7864d49490f/66071a4c-ef5b-49be-af1c-c0805d048730/image.png)

## 21.

이 기법을 도입하면서 출현한 **‘참조자 반환’** 함수는 어느 경우이든 복잡하게 구현될 일이 없다.  ****

**첫 번째 줄에서** 지역 정적 객체를 정의/초기화하고, 

**두 번째 줄에서** 그 객체의 참조자를 반환하면 끝이다. 함수 본문이 지극히 단순하다 보니, 인라인해도 좋겠다는 생각도 든다. 

특히 이 함수의 호출빈도가 잦다면 더욱 그렇다*(항목 30 참조)*.

그러나 참조자 반환 함수는 내부적으로 정적 객체를 쓰기 때문에, 다중스레드 시스템에서는 동작에 장애가 생길 수도 있다. 다중스레드, 혹시나 이것이 돌아가는 프로그램이라면 비상수 정적 객체(지역 객체이든 비지역 객체이든)는 온갖 골칫거리의 시한폭탄이다. 골칫거리를 다루는 한 가지 방법으로 프로그램이 다중스레드로 돌입하기 전의 시동 단계에서 참조자 반환 함수를 전부 손으로 호줄해 줄 수 있다. 이렇게 하면 초기화에 관계된 **경쟁 상태(race condition)**가 없어진다.

### reference

---

함수가 참조자를 반환할 때 어떤 경우에 자주 쓰이는 지와 이것에 대해 익숙해지기

## 22.

물론 초기화 순서 문제를 방지하기 위해 이처럼 참조자 반환 함수를 사용하는 아이디어는 여러분이 객체들의 초기화 순서를 제대로 맞춰 둔다는 전제조건이 뒷받침되어 있어야 말이 된다. 이를테면 객체 B가 초기화되기 전에 객체 A가 초기화되어야 하는데, A의 초기화가 B의 초기화에 의존하도록 만들어져 있다면 이건 진짜 문제이다.  그렇지만 이러한 악성 시나리오를 사전에 잘 없애놓고 간다면 이번 항목에서 가르쳐 드린 방법은 최소한 단일 스레드 애플리케이션에서는 확실하다.

## 23.

[정리]
어떤 객체가 초기화되기 전에 그 객체를 사용하는 일이 생기지 않도록 하려면 **딱 세가지**만 기억해 두고 실천하면 된다. 

- **첫째)** 멤버가 아닌 기본제공 타입 객체는 여러분 손으로 직접 초기화하자
- **둘째)** 객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용하자.
- **마지막으로)** 별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두에 두고 이러한 불확실성을 피해서 프로그램을 설계해야 한다.

<aside>
💡

이것만은 잊지 말기

- 기본제공 타입의 객체는 직접 손으로 초기화합니다. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문입니다.
- 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용합시다. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열합시다.
- 여러 번역 단위에 있는 비지혁 정적 객체들의 초기화 순서 문제는 피해서 설계해야 합니다. 
비지역 정적 객체를 지역 정적 객체로 바꾸면 됩니다.
</aside>